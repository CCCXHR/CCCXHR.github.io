{"posts":[{"title":"普及2016赛后回顾","content":"T1.买铅笔 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; int main() { // freopen(&quot;pencil.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;pencil.out&quot;,&quot;w&quot;,stdout); int n; int a1,a2,b1,b2,c1,c2; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%d%d%d%d%d%d&quot;,&amp;a1,&amp;a2,&amp;b1,&amp;b2,&amp;c1,&amp;c2); int ans1=0,ans2=0,ans3=0; int ans; int ls=0; ls=n%a1; if(ls!=0) ans1=((n-ls)/a1+1)*a2; else ans1=a1/n*a2; ls=n%b1; if(ls!=0) ans2=((n-ls)/b1+1)*b2; else ans2=b1/n*b2; ls=n%c1; if(ls!=0) ans3=((n-ls)/c1+1)*c2; else ans3=c1/n*c2; ans=min(min(ans1,ans2),ans3); printf(&quot;%d&quot;,ans); return 0; } 得分：50 考场思路： 逐个查看要买多少和，比较得出最优解并输出。 错误： 模数与被模数写反。 AC代码： #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; int main() { //freopen(&quot;pencil.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;pencil.out&quot;,&quot;w&quot;,stdout); int n; int a1,a2,b1,b2,c1,c2; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%d%d%d%d%d%d&quot;,&amp;a1,&amp;a2,&amp;b1,&amp;b2,&amp;c1,&amp;c2); int ans1=0,ans2=0,ans3=0; int ans; int ls=0; ls=n%a1; ans1=n/a1; if(ls) ++ans1; ls=n%b1; ans2=n/b1; if(ls) ++ans2; ls=n%c1; ans3=n/c1; if(ls) ++ans3; ans=min(min(ans1*a2,ans2*b2),ans3*c2); printf(&quot;%d&quot;,ans); return 0; } 更改： 推翻重写。 思路： 对于每种铅笔： 查看要买多少盒 如果不够用，要买的盒数+1（答案是要买的盒数*价格） 取最小值输出。 T2.回文日期 考场代码： #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; int month[13]={0,31,0,31,30,31,30,31,31,30,31,30,31}; inline bool check(string q) { string s; int cnt=q.size(); for(register int i=cnt-1;i&gt;=0;--i) s+=q[i]; return (s==q); } int main() { // freopen(&quot;date.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;date.out&quot;,&quot;w&quot;,stdout); string date1,date2; cin&gt;&gt;date1&gt;&gt;date2; if(date1==date2) { if(check(date2)) cout&lt;&lt;1; else cout&lt;&lt;0; return 0; } cout&lt;&lt;0; return 0; } 得分：64 思路： 看到这句话，我想到了啥······ 对于60%60\\%60%的数据，满足date1=date2date1=date2date1=date2。 这意味着什么？date1到date2只有一个日期（date1）。只需要判断date1是不是回文，答案不是1就是0。最后如果date1=date2date1\\not ={date2}date1​=date2那么输出0碰运气。结果60+4(好运来~)。 AC： #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; inline bool check(int x) { int pre=x; int q=0; while(x) { q=q*10+x%10; x/=10; } return (pre==q); } inline void hhh(int &amp;val,int &amp;date,int k) { int t=1; for(register int i=0;i&lt;k;++i) { val=val+(date%10)*t; date/=10; t*=10; } } inline bool rn(int year) { return ((year%4==0&amp;&amp;year%100!=0)||(year%400==0)); } inline int make(int y,int m,int d) { return d+m*100+y*10000; } int month_day[13]={-1,31,28,31,30,31,30,31,31,30,31,30,31}; int main() { int date1,date2; scanf(&quot;%d%d&quot;,&amp;date1,&amp;date2); int year=0,month=0,day=0; int ty=0,tm=0,td=0; if(date1==date2) { printf(&quot;%d&quot;,check(date1)); return 0; } hhh(day,date1,2); hhh(month,date1,2); hhh(year,date1,4); hhh(td,date2,2); hhh(tm,date2,2); hhh(ty,date2,4); int ans=0; while(day!=td||month!=tm||year!=ty) { // cout&lt;&lt;make(year,month,day)&lt;&lt;endl; // system(&quot;pause&quot;); if(check(make(year,month,day))) ++ans; ++day; int md=month_day[month]; if(md==28) md=(rn(year)==1)?29:28; if(day&gt;md) { day=1; ++month; } if(month==13) { month=1; ++year; } } if(check(make(year,month,day))) ++ans; printf(&quot;%d&quot;,ans); return 0; } 更改：完全推翻重写！ 思路： 把年月日分开处理。如果当前日期=\\not ={}​=目标日期，那么day+1。如果day超过了这个月的天数（2月特判即可），那么month+1，day归1。如果month超过了12，那么month&amp;day归一。year+1。 最后记得要处理一下date2。 T3.海港 考场代码： #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; #define hour 86400 struct Pig { int time,from,boat; }; Pig pg[300002]; bool mark[100001]; int tail=0; vector&lt;int&gt; answer; int main() { // freopen(&quot;port.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;port.out&quot;,&quot;w&quot;,stdout); int n,x,y,z; int an=0; scanf(&quot;%d&quot;,&amp;n); for(register int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;z); scanf(&quot;%d&quot;,&amp;x); for(register int j=1;j&lt;=x;++j) { scanf(&quot;%d&quot;,&amp;y); pg[++tail].time=z; pg[tail].from=y; pg[tail].boat=i; } } if(n==1) { for(register int i=1;i&lt;=tail;++i) if(mark[pg[i].from]==0) { mark[pg[i].from]=1; ++an; } printf(&quot;%d&quot;,an); return 0; } // cout&lt;&lt;&quot;ok&quot;; pg[tail+1].from=-1; int lin_toto; int ans; while(tail&gt;0) { ans=0; if(pg[tail].boat==pg[tail+1].boat) { --tail; continue; } lin_toto=tail; memset(mark,0,sizeof(mark)); // cout&lt;&lt;&quot;ok&quot;; while(pg[tail].time-pg[lin_toto].time&lt;hour&amp;&amp;lin_toto&gt;=1) { if(mark[pg[lin_toto].from]==0) { mark[pg[lin_toto].from]=1; // cout&lt;&lt;pg[lin_toto].from&lt;&lt;&quot; &quot;; ++ans; } --lin_toto; // cout&lt;&lt;&quot;ok&quot;&lt;&lt;endl; } --tail; // printf(&quot;\\n&quot;); // printf(&quot;%d\\n&quot;,ans); answer.push_back(ans); } for(int i=answer.size()-1;i&gt;=0;--i) cout&lt;&lt;answer[i]&lt;&lt;endl; return 0; } 得分：70 思路： 记录每个乘客来到海港的时间、国籍、乘坐船只，同意加入数组（模拟队列）。对于每个乘客，对应国籍人数+1，乘客出队。每艘船统计完毕后输出答案并且清空结果数值。（这里需要逆序输出，所以是先压入了vector最后在输出的） AC代码 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;string&gt; #include&lt;queue&gt; using namespace std; #define hour 86400 #define MAXX 100001 struct Pig { int time,from; }; queue&lt;Pig&gt; pig; int cmp=1; int tot[MAXX]; int main() { int n,x,y,z; scanf(&quot;%d&quot;,&amp;n); int ans=0; while(n--) { scanf(&quot;%d%d&quot;,&amp;x,&amp;y); cmp=pig.front().time; while(!pig.empty()) { if(pig.front().time+hour&gt;x) break; --tot[pig.front().from]; if(tot[pig.front().from]==0) --ans; pig.pop(); } while(y--) { scanf(&quot;%d&quot;,&amp;z); pig.push((Pig){x,z}); ++tot[z]; if(tot[z]==1) ++ans; } printf(&quot;%d\\n&quot;,ans); } return 0; } 修改 重写。 思路 对于每个乘客，加入一个队列，队列记录的信息包括到达时间以及国籍。每次先弹出已经停留超过一小时的乘客（这些乘客的统计信息已经在前面输出）。如果某国籍人数降为0，那么答案-1（少了一个国家的人）。然后输入，如果这个乘客是某国籍的第一个来港者（24小时内），那么答案+1。最后输出答案。 T4.魔法阵 考场代码： #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; #define MAXM 61 int ans[MAXM][4]; int x[MAXM]; int main() { // freopen(&quot;magic.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;magic.out&quot;,&quot;w&quot;,stdout); int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(register int i=1;i&lt;=m;++i) scanf(&quot;%d&quot;,&amp;x[i]); for(register int i=1;i&lt;=m;++i) { for(register int j=1;j&lt;=m;++j) { for(register int k=1;k&lt;=m;++k) { for(register int l=1;l&lt;=m;++l) { if((x[i]&lt;x[j]&amp;&amp;x[j]&lt;x[k]&amp;&amp;x[k]&lt;x[l])&amp;&amp;(x[j]-x[i]==2*(x[l]-x[k]))&amp;&amp;(x[j]-x[i]&lt;(x[k]*1.0-x[j]*1.0)/3.0)) { // cout&lt;&lt;x[i]&lt;&lt;&quot; &quot;&lt;&lt;x[j]&lt;&lt;&quot; &quot;&lt;&lt;x[k]&lt;&lt;&quot; &quot;&lt;&lt;x[l]&lt;&lt;endl; ++ans[i][0]; ++ans[j][1]; ++ans[k][2]; ++ans[l][3]; } } } } } for(register int i=1;i&lt;=m;++i) { for(register int j=0;j&lt;4;++j) printf(&quot;%d &quot;,ans[i][j]); printf(&quot;\\n&quot;); } return 0; } **得分：**25分 考场思路： 枚举每个魔法阵的ABCD四个物品，判断条件是否满足，最后输出。 亿些小小小小的问题 对评测姬性能估计错误，数组开小，经检查，将数组大小开至101可将得分优化至35。 55分代码： #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; #define MAXM 2001 int ans[MAXM][4]; typedef struct node { int val,index; }; node x[MAXM]; bool cmp(node x,node y) { return x.val&lt;y.val; } int main() { // freopen(&quot;magic.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;magic.out&quot;,&quot;w&quot;,stdout); int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(register int i=0;i&lt;m;++i) { scanf(&quot;%d&quot;,&amp;x[i].val); x[i].index=i; } sort(x,x+m,cmp); for(register int i=0;i&lt;m;++i) { for(register int j=i+1;j&lt;m;++j) { for(register int k=j+1;k&lt;m;++k) { for(register int l=k+1;l&lt;m;++l) { if((x[i].val&lt;x[j].val&amp;&amp;x[j].val&lt;x[k].val&amp;&amp;x[k].val&lt;x[l].val)&amp;&amp;(x[j].val-x[i].val==2*(x[l].val-x[k].val))&amp;&amp;(x[j].val-x[i].val&lt;(x[k].val*1.0-x[j].val*1.0)/3.0)) { // cout&lt;&lt;x[i]&lt;&lt;&quot; &quot;&lt;&lt;x[j]&lt;&lt;&quot; &quot;&lt;&lt;x[k]&lt;&lt;&quot; &quot;&lt;&lt;x[l]&lt;&lt;endl; ++ans[x[i].index][0]; ++ans[x[j].index][1]; ++ans[x[k].index][2]; ++ans[x[l].index][3]; } } } } } for(register int i=0;i&lt;m;++i) { for(register int j=0;j&lt;4;++j) printf(&quot;%d &quot;,ans[i][j]); printf(&quot;\\n&quot;); } return 0; } 更改： 增加了排序。 思路： 因为 大魔法师认为，当且仅当四个编号为a,b,c,da,b,c,da,b,c,d的魔法物品满足 Xa&lt;Xb&lt;Xc&lt;XdX_a &lt; X_b &lt; X_c &lt; X_dXa​&lt;Xb​&lt;Xc​&lt;Xd​ ······ 可以对其进行一次快速排序，然后就可以缩小i,j,k,li,j,k,li,j,k,l四个变量的枚举范围。 ","link":"https://cccxhr.github.io/post/pj2016/"}]}